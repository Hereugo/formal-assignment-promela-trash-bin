# 1 "trash_bin.pml"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 418 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "trash_bin.pml" 2
# 64 "trash_bin.pml"
mtype:comp = { OuterDoor, LockOuterDoor, TrapDoor }

mtype:pos = { closed, open };

mtype:ram_pos = { idle, compress };

mtype:truck_pos = { arrived, start_emptying, emptied };


typedef bin_t {

 mtype:pos out_door;
 mtype:pos lock_out_door;
 mtype:pos trap_door;
 mtype:ram_pos ram;

 byte trash_in_outer_door;
 byte trash_on_trap_door;

 byte trash_compressed;
 byte trash_uncompressed;

 bool full_capacity;
 bool trap_destroyed;
 bool busy;
}




bin_t bin_status;


byte max_capacity;


bool has_trash;




chan change_bin = [1] of { mtype:comp, mtype:pos };

chan bin_changed = [0] of { mtype:comp, bool };

chan user_closed_outer_door = [0] of { bool };


chan weigh_trash = [0] of { bool };
chan trash_weighted = [0] of { byte };


chan change_ram = [0] of { mtype:ram_pos };
chan ram_changed = [0] of { bool };


chan scan_card_user = [1] of { byte };
chan can_deposit_trash = [1] of { byte, bool };


chan check_user = [0] of { byte };
chan user_valid = [0] of { byte, bool };


chan request_truck = [1] of { byte };
chan change_truck = [1] of { mtype:truck_pos, byte };

chan empty_bin = [0] of { bool };
chan bin_emptied = [0] of { bool };





proctype bin(byte bin_id) {
 do

 :: change_bin?OuterDoor, closed ->
  if
  :: bin_status.out_door == open ->
   bin_status.out_door = closed;
   user_closed_outer_door!true;
   bin_changed!OuterDoor, true;
  fi
 :: change_bin?OuterDoor, open ->
  if
  :: bin_status.out_door == closed && bin_status.lock_out_door == open ->
   bin_status.out_door = open;
   bin_changed!OuterDoor, true;
  fi
 :: change_bin?LockOuterDoor, closed ->
  if
  :: bin_status.lock_out_door == open && bin_status.out_door == closed ->
   atomic {
    bin_status.lock_out_door = closed;

    if
    :: bin_status.trash_in_outer_door > 0 && bin_status.trap_door == closed && bin_status.trash_on_trap_door == 0 ->

     bin_status.trash_on_trap_door = bin_status.trash_in_outer_door;
     bin_status.trash_in_outer_door = 0;
    :: bin_status.trash_in_outer_door > 0 && bin_status.trap_door == closed && bin_status.trash_on_trap_door > 0 ->

     skip;
    :: bin_status.trash_in_outer_door > 0 && bin_status.trap_door == open ->

     assert(bin_status.trash_on_trap_door == 0);
     bin_status.trash_uncompressed = bin_status.trash_uncompressed + bin_status.trash_in_outer_door;
     bin_status.trash_in_outer_door = 0;
    fi
   }
   bin_changed!LockOuterDoor, true;
  fi
 :: change_bin?LockOuterDoor, open ->
  if
  :: bin_status.lock_out_door == closed && bin_status.out_door == closed ->
   bin_status.lock_out_door = open;
   bin_changed!LockOuterDoor, true;
  fi

 :: weigh_trash?true ->
  if
  :: bin_status.trap_door == closed ->
   trash_weighted!bin_status.trash_on_trap_door;
  fi
 :: change_bin?TrapDoor, closed ->
  if
  :: bin_status.trap_door == open && bin_status.ram == idle ->
   bin_status.trap_door = closed;
   bin_changed!TrapDoor, true;
  :: bin_status.trap_door == open && bin_status.ram == compress ->
   bin_status.trap_destroyed = true;
   bin_changed!TrapDoor, false;
  fi
 :: change_bin?TrapDoor, open ->
  if
  :: bin_status.trap_door == closed ->
   atomic {
    bin_status.trap_door = open;

    if
    :: bin_status.trash_on_trap_door > 0 ->
     bin_status.trash_uncompressed = bin_status.trash_uncompressed + bin_status.trash_on_trap_door;
     bin_status.trash_on_trap_door = 0;
    :: else ->
     skip;
    fi
   }
   bin_changed!TrapDoor, true;
  fi

 :: change_ram?compress ->
  if
  :: bin_status.ram == idle ->
   atomic {
    bin_status.ram = compress;
    if
    :: bin_status.trap_door == open ->

     bin_status.trash_compressed = bin_status.trash_compressed + bin_status.trash_uncompressed / 2;
     bin_status.trash_uncompressed = 0;
    :: bin_status.trap_door == closed ->

     bin_status.trap_destroyed = true;
    fi
   }
   ram_changed!true;
  fi
 :: change_ram?idle ->
  if
  :: bin_status.ram == compress ->
   bin_status.ram = idle;
   ram_changed!true;
  fi

 :: empty_bin?true ->
  if
  :: bin_status.out_door == closed && bin_status.lock_out_door == closed && bin_status.ram == idle ->
   atomic {
    bin_status.trash_compressed = 0;
    bin_status.trash_uncompressed = 0;

    bin_status.full_capacity = false;
   }
   bin_emptied!true;
  fi
 od
}



proctype server() {
 byte user_id;
 do

 :: check_user?user_id ->
  if

  :: user_id != 42 ->
   user_valid!user_id, true;
  :: user_id == 42 ->
   user_valid!user_id, false;
  fi
 od
}



proctype truck() {
 byte bin_id;
 do
 :: request_truck?<bin_id> ->

  change_truck!arrived,true;

  change_truck?start_emptying, true;




  assert(nempty(request_truck));


  request_truck?bin_id;



  empty_bin!true;
  bin_emptied?true;


  change_truck!emptied, true;
 od
}




proctype user(byte user_id; byte trash_size) {
 do

 :: !has_trash ->
  has_trash = true;

 :: has_trash ->

  scan_card_user!user_id;
  if
  :: can_deposit_trash?user_id, true ->
   bin_changed?LockOuterDoor, true;

   change_bin!OuterDoor, open;
   bin_changed?OuterDoor, true;
   atomic {
    if
    :: bin_status.trash_in_outer_door == 0 ->

     bin_status.trash_in_outer_door = trash_size;
     has_trash = false;
    :: bin_status.trash_in_outer_door > 0 ->

     skip;
    fi
   }

   change_bin!OuterDoor, closed;
   bin_changed?OuterDoor, true;
  :: can_deposit_trash?user_id, false ->
   skip;
  fi
 od
}




proctype main_control() {
 byte bin_id;
 byte user_id;
 byte trash_weight;

 do
 :: scan_card_user?user_id ->


  bool valid;
  check_user!user_id;
  user_valid?user_id, valid;
  if
  :: valid == true ->
   if
   :: (!bin_status.full_capacity && !bin_status.trap_destroyed && !bin_status.busy) ->
    bin_status.busy = true;
    can_deposit_trash!user_id, true;
    change_bin!LockOuterDoor, open;
   :: else ->
    can_deposit_trash!user_id, false;
   fi
  :: else ->
   can_deposit_trash!user_id, false;
  fi
 :: user_closed_outer_door?true ->



  change_bin!LockOuterDoor, closed;
  bin_changed?LockOuterDoor, true;


  weigh_trash!true;
  trash_weighted?trash_weight;
  if
  :: bin_status.full_capacity == true ->



   skip;
  :: else ->

   change_bin!TrapDoor, open;
   bin_changed?TrapDoor, true;

   change_ram!compress;
   ram_changed?true;

   if
   :: bin_status.trash_compressed >= max_capacity ->
    bin_status.full_capacity = true;
    request_truck!bin_id;
   :: else ->
    skip;
   fi
  fi

  change_ram!idle;
  ram_changed?true;

  change_bin!TrapDoor, closed;
  bin_changed?TrapDoor, true;

  bin_status.busy = false;


 :: change_truck?arrived, true ->
  change_truck!start_emptying, true;
  change_truck?emptied, true;
 od
}



init {
 byte proc;
 atomic {



  proc = 0;
  do
  :: proc < 1 ->

   bin_status.out_door = closed;
   bin_status.lock_out_door = closed;
   bin_status.trap_door = closed;
   bin_status.ram = idle;
   bin_status.trash_in_outer_door = 0;
   bin_status.trash_on_trap_door = 0;
   bin_status.trash_compressed = 0;
   bin_status.trash_uncompressed = 0;
   bin_status.full_capacity = false;
   bin_status.trap_destroyed = false;
   bin_status.busy=false;
   max_capacity = 2;

   run bin(proc);
   proc++;
  :: proc == 1 ->
   break;
  od;


  proc = 0;
  byte trash_size = 2;
  has_trash = true;
  run user(proc, trash_size);


  run server();

  run truck();


  run main_control();
 }
}
